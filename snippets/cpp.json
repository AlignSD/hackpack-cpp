{
    "BIT.h": {
        "body": [
            "template <typename T>", 
            "struct BIT {", 
            "\tvector<T> s;", 
            "\tint n;", 
            "\tBIT(int n) : s(n + 1), n(n) {}", 
            "\tvoid update(int i, T v) {", 
            "\t\tfor (i++; i <= n; i += i & -i) s[i] += v;", 
            "\t}", 
            "\tT query(int i) {", 
            "\t\tT ans = 0;", 
            "\t\tfor (i++; i; i -= i & -i) ans += s[i];", 
            "\t\treturn ans;", 
            "\t}", 
            "\tT query(int l, int r) { return query(r) - query(l - 1); }", 
            "\tint kth(T k) { // returns n if k > sum of tree", 
            "\t\tif (k <= 0) return -1;", 
            "\t\tint i = 0;", 
            "\t\tfor (int pw = 1 << __lg(n); pw; pw >>= 1)", 
            "\t\t\tif (i + pw <= n && s[i + pw] < k) k -= s[i += pw];", 
            "\t\treturn i;", 
            "\t}", 
            "};"
        ], 
        "description": "Query [l, r] sums, and point updates.\nkth() returns the smallest index i s.t. query(0, i) >= k", 
        "prefix": [
            "hack_BIT"
        ]
    }, 
    "DSU.h": {
        "body": [
            "struct DSU {", 
            "\tvector<int> s;", 
            "\tDSU(int n) : s(n, -1) {}", 
            "\tint find(int i) { return s[i] < 0 ? i : s[i] = find(s[i]); }", 
            "\tbool join(int a, int b) {", 
            "\t\ta = find(a), b = find(b);", 
            "\t\tif (a == b) return false;", 
            "\t\tif (s[a] > s[b]) swap(a, b);", 
            "\t\ts[a] += s[b], s[b] = a;", 
            "\t\treturn true;", 
            "\t}", 
            "\tint size(int i) { return -s[find(i)]; }", 
            "\tbool same(int a, int b) { return find(a) == find(b); }", 
            "};"
        ], 
        "description": "Maintains union of disjoint sets", 
        "prefix": [
            "hack_DSU"
        ]
    }, 
    "KDBIT.h": {
        "body": [
            "template <class T, int... Ns>", 
            "struct BIT {", 
            "\tT val = 0;", 
            "\tvoid update(T v) { val += v; }", 
            "\tT query() { return val; }", 
            "};", 
            "template <class T, int N, int... Ns>", 
            "struct BIT<T, N, Ns...> {", 
            "\tBIT<T, Ns...> bit[N + 1];", 
            "\t// map<int, BIT<T, Ns...>> bit;", 
            "\t// if the memory use is too high", 
            "\ttemplate <class... Args>", 
            "\tvoid update(int i, Args... args) {", 
            "\t\tfor (i++; i <= N; i += i & -i) bit[i].update(args...);", 
            "\t}", 
            "\ttemplate <class... Args>", 
            "\tT query(int i, Args... args) {", 
            "\t\tT ans = 0;", 
            "\t\tfor (i++; i; i -= i & -i) ans += bit[i].query(args...);", 
            "\t\treturn ans;", 
            "\t}", 
            "\ttemplate <class... Args,", 
            "\t\t\t\t\t\tenable_if_t<(sizeof...(Args) ==", 
            "\t\t\t\t\t\t\t\t\t\t\t\t 2 * sizeof...(Ns))>* = nullptr>", 
            "\tT query(int l, int r, Args... args) {", 
            "\t\treturn query(r, args...) - query(l - 1, args...);", 
            "\t}", 
            "};"
        ], 
        "description": "$k$-dimensional BIT. \\texttt{BIT<int, N, M>}\ngives an $N \\times M$ BIT.\n\\\\ Query: \\texttt{bit.query(x1, x2, y1, y2)} Update:\n\\texttt{bit.update(x, y, delta)} Time: $O(\\log^k n)$ Status:\nTested", 
        "prefix": [
            "hack_KDBIT"
        ]
    }, 
    "NDimensionalVector.h": {
        "body": [
            "template <int D, typename T>", 
            "struct Vec : public vector<Vec<D - 1, T>> {", 
            "\tstatic_assert(D >= 1,", 
            "\t\t\t\t\t\t\t\t\"Vector dimension must be greater than zero!\");", 
            "\ttemplate <typename... Args>", 
            "\tVec(int n = 0, Args... args)", 
            "\t\t: vector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {}", 
            "};", 
            "template <typename T>", 
            "struct Vec<1, T> : public vector<T> {", 
            "\tVec(int n = 0, const T& val = T()) : vector<T>(n, val) {}", 
            "};"
        ], 
        "prefix": [
            "hack_NDimensionalVector"
        ]
    }, 
    "RMQ.h": {
        "body": [
            "template <typename T, class Compare = less<T>>", 
            "struct RMQ {", 
            "\tvector<vector<T>> t;", 
            "\tCompare cmp;", 
            "\tRMQ(vector<T>& a) : t(__lg(a.size()) + 1, a) {", 
            "\t\tint n = a.size(), lg = __lg(n);", 
            "\t\tfor (int k = 1, len = 1; k <= lg; k++, len <<= 1)", 
            "\t\t\tfor (int i = 0; i + 2 * len - 1 < n; i++)", 
            "\t\t\t\tt[k][i] = min(t[k - 1][i], t[k - 1][i + len], cmp);", 
            "\t}", 
            "\tT query(int a, int b) {", 
            "\t\tint k = __lg(b - a + 1), len = 1 << k;", 
            "\t\treturn min(t[k][a], t[k][b - len + 1], cmp);", 
            "\t}", 
            "};"
        ], 
        "description": "Constant time subarray min/max queries for a\nfixed array Time: $O(n log n)$ initialization and $O(1)$\nqueries. Status: Tested", 
        "prefix": [
            "hack_RMQ"
        ]
    }, 
    "Submasks.h": {
        "body": [
            "for (int mask = 0; mask < (1 << n); mask++)", 
            "\tfor (int sub = mask; sub; sub = (sub - 1) & mask)", 
            "// do thing"
        ], 
        "prefix": [
            "hack_Submasks"
        ]
    }
}